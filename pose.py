import math
import json
import datetime
import numpy as np

class Pose():
	''' Data structure that represents a protein '''
	def __init__(self):
		with open('AminoAcids.json') as f: AminoAcids = json.load(f)
		Masses = {
			'H':1.008,    'He':4.003,   'Li':6.941,   'Be':9.012,
			'B':10.811,   'C':12.011,   'N':14.007,   'O':15.999,
			'F':18.998,   'Ne':20.180,  'Na':22.990,  'Mg':24.305,
			'Al':26.982,  'Si':28.086,  'P':30.974,   'S':32.066,
			'Cl':35.453,  'Ar':39.948,  'K':39.098,   'Ca':40.078,
			'Sc':44.956,  'Ti':47.867,  'V':50.942,   'Cr':51.996,
			'Mn':54.938,  'Fe':55.845,  'Co':58.933,  'Ni':58.693,
			'Cu':63.546,  'Zn':65.38,   'Ga':69.723,  'Ge':72.631,
			'As':74.922,  'Se':78.971,  'Br':79.904,  'Kr':84.798,
			'Rb':84.468,  'Sr':87.62,   'Y':88.906,   'Zr':91.224,
			'Nb':92.906,  'Mo':95.95,   'Tc':98.907,  'Ru':101.07,
			'Rh':102.906, 'Pd':106.42,  'Ag':107.868, 'Cd':112.414,
			'In':114.818, 'Sn':118.711, 'Sb':121.760, 'Te':126.7,
			'I':126.904,  'Xe':131.294, 'Cs':132.905, 'Ba':137.328,
			'La':138.905, 'Ce':140.116, 'Pr':140.908, 'Nd':144.243,
			'Pm':144.913, 'Sm':150.36,  'Eu':151.964, 'Gd':157.25,
			'Tb':158.925, 'Dy':162.500, 'Ho':164.930, 'Er':167.259,
			'Tm':168.934, 'Yb':173.055, 'Lu':174.967, 'Hf':178.49,
			'Ta':180.948, 'W':183.84,   'Re':186.207, 'Os':190.23,
			'Ir':192.217, 'Pt':195.085, 'Au':196.967, 'Hg':200.592,
			'Tl':204.383, 'Pb':207.2,   'Bi':208.980, 'Po':208.982,
			'At':209.987, 'Rn':222.081, 'Fr':223.020, 'Ra':226.025,
			'Ac':227.028, 'Th':232.038, 'Pa':231.036, 'U':238.029,
			'Np':237,     'Pu':244}
		data ={
			'Energy':0,
			'Rg':0,
			'Mass':0,
			'Size':0,
			'FASTA':None,
			'Amino Acids':{},
			'Atoms':{},
			'Bonds':{},
			'Coordinates':np.array([[0, 0, 0]])}
		self.AminoAcids = AminoAcids
		self.Masses = Masses
		self.data = data
	def PDB_entry(self, atom, n, a, l, r, c, s, i, x, y, z, o, t, q, e):
		''' Construct a PDB atom entry '''
		ATOM = '{:<6}'.format(atom)
		N = '{:>5}  '.format(n)
		A = '{:<4}'.format(a)
		L = '{:>0}'.format(l)
		R = '{:>3}'.format(r)
		C = '{:>2}'.format(c)
		S = '{:>4}'.format(s)
		I = '{:>1}   '.format(i)
		X = '{:>8.3f}'.format(x)
		Y = '{:>8.3f}'.format(y)
		Z = '{:>8.3f} '.format(z)
		O = '{:>5.2f} '.format(o)
		T = '{:>5.2f} '.format(t)
		Q = '{:>9.3f} '.format(q)
		E = '{:<2} \n'.format(e)
		entry = ATOM + N + A + L + R + C + S + I + X + Y + Z + O + T + Q + E
		return(entry)
	def PDB(self, filename):
		''' Export pose to a .pdb file '''
		with open(filename, 'w') as f:
			DATE = datetime.date.today().strftime("%d-%b-%Y")
			H1 = 'HEADER'+' '*44+DATE+' '*3+'XXXX'+' '*11+'\n'
			H2 = 'EXPDTA'+' '*4+'THEORETICAL MODEL'+' '*52+'\n'
			H3 = 'REMARK 220 REMARK: MODEL GENERATED BY SARI SABBAN'+' '*30+'\n'
			f.write(H1)
			f.write(H2)
			f.write(H3)
			atoms = self.data['Atoms'].items()
			aminoacids = self.data['Amino Acids']
			coordinates = self.data['Coordinates']
			AAindex = 0
			BBlen = len(self.data['Amino Acids'][AAindex][2])
			SClen = len(self.data['Amino Acids'][AAindex][3])
			length = BBlen + SClen - 1
			for atom, coordinate in zip(atoms, coordinates):
				A = 'ATOM'
				n = atom[0] + 1
				a = atom[1][0]
				l = ''
				r = self.AminoAcids[self.data['Amino Acids']\
				[AAindex][0]]['Tricode']
				c = self.data['Amino Acids'][AAindex][1]
				s = AAindex + 1
				i = ''
				x = coordinate[0]
				y = coordinate[1]
				z = coordinate[2]
				o = 1.0
				t = 0.0
				q = atom[1][2]
				e = atom[1][1]
				line = self.PDB_entry(A,n,a,l,r,c,s,i,x,y,z,o,t,q,e)
				f.write(line)
				if length != 0:
					length -= 1
				elif length == 0:
					AAindex += 1
					try:
						BBlen = len(self.data['Amino Acids'][AAindex][2])
						SClen = len(self.data['Amino Acids'][AAindex][3])
						length = BBlen + SClen - 1
					except:
						continue
			TER = 'TER'
			f.write(TER)
	def GetAtom(self, AA, atom):
		''' Get specific atom coordinates '''
		n = 0
		if AA != 0 and (atom == 'H2' or atom == 'H3'):
			raise Exception('Amino acid does not have this atom')
			exit()
		if AA == 0:
			n = 2
			H2 = self.data['Amino Acids'][AA][2][2]
			H3 = self.data['Amino Acids'][AA][2][3]
		N  = self.data['Amino Acids'][AA][2][0]
		H1 = self.data['Amino Acids'][AA][2][1]
		CA = self.data['Amino Acids'][AA][2][2 + n]
		HA = self.data['Amino Acids'][AA][2][3 + n]
		C  = self.data['Amino Acids'][AA][2][4 + n]
		O  = self.data['Amino Acids'][AA][2][5 + n]
		if atom.upper() == 'N' :
			coordinates = self.data['Coordinates'][N]
			return(coordinates)
		if atom.upper() == 'H1':
			coordinates = self.data['Coordinates'][H1]
			return(coordinates)
		if atom.upper() == 'H2':
			coordinates = self.data['Coordinates'][H2]
			return(coordinates)
		if atom.upper() == 'H3':
			coordinates = self.data['Coordinates'][H3]
			return(coordinates)
		if atom.upper() == 'CA':
			coordinates = self.data['Coordinates'][CA]
			return(coordinates)
		if atom.upper() == 'HA':
			coordinates = self.data['Coordinates'][HA]
			return(coordinates)
		if atom.upper() == 'C' :
			coordinates = self.data['Coordinates'][C]
			return(coordinates)
		if atom.upper() == 'O' :
			coordinates = self.data['Coordinates'][O]
			return(coordinates)
		try:
			AminoAcid = self.data['Amino Acids'][AA][0]
			L = self.AminoAcids[AminoAcid]['Sidechain Atoms']
			amino_index = [x[0] for x in L].index(atom)
			i = self.data['Amino Acids'][AA][3][amino_index]
			coordinates = self.data['Coordinates'][i]
		except ValueError:
			raise Exception('Amino acid does not have this atom')
		return(coordinates)
	def Insert(self, AA, X, Y, Z):
		''' Inser a backbone or sidechain given its initial coordinates '''
		atoms = np.array(self.AminoAcids[AA]['Vectors']) + np.array([X, Y, Z])
		return(atoms)
	def Flip(self, AA):
		''' Flip an amino acid 180 degrees on CA's H1 H2 axis'''
		p = AA[2]
		AA = AA - p
		H1 = AA[3]
		H2 = AA[4]
		u = np.cross(H1, H2)
		lu = np.linalg.norm(u)
		u = u / lu
		TM = np.array([
		[2*u[0]**2-1, 2*u[0]*u[1], 2*u[0]*u[2]],
		[2*u[0]*u[1], 2*u[1]**2-1, 2*u[2]*u[2]],
		[2*u[0]*u[2], 2*u[2]*u[2], 2*u[2]**2-1]])
		AA = np.matmul(AA, TM)
		AA = AA + p
		return(AA)
	def Amino(self, backbone_type, X, Y, Z, aa, index, flip=False):
		''' Construct an amino acid and add its coordinates to the data '''
		BB = self.Insert(backbone_type, X, Y, Z)
		SC = self.Insert(aa, X, Y, Z)
		AA = np.insert(BB, index, SC, axis=0)
		if flip: AA = self.Flip(AA)
		self.data['Coordinates'] = \
		np.append(self.data['Coordinates'], AA, axis=0)
		if backbone_type == 'Backbone' or backbone_type == 'Backbone start':
			self.data['Coordinates'] = \
			np.delete(self.data['Coordinates'], [0], axis=0)
			if aa == 'P':
				self.data['Coordinates'] = \
				np.delete(self.data['Coordinates'], [1], axis=0)
	def Atoms(self, AA, chain, backbone_type, BB_index, AA_index, I):
		''' Construct, and add to pose, atom and amino acid identities '''
		BB = backbone_type[:BB_index]
		if backbone_type == self.AminoAcids['Backbone']['Backbone Atoms'] \
		or backbone_type == self.AminoAcids['Backbone start']['Backbone Atoms']:
			if AA == 'P': BB.pop(1)
		BB = BB + self.AminoAcids[AA]['Sidechain Atoms']
		BB = BB + backbone_type[BB_index:]
		BBi = []
		SCi = []
		BBtop = BB_index
		SCtop = len(self.AminoAcids[AA]['Sidechain Atoms'])
		for atomi, v in enumerate(BB, I):
			self.data['Atoms'][atomi] = v
			if BBtop != 0:
				BBi.append(atomi)
				BBtop -= 1
			elif BBtop == 0 and SCtop != 0:
				SCi.append(atomi)
				SCtop -= 1
			else:
				BBi.append(atomi)
		self.data['Amino Acids'][AA_index] = (AA, chain, BBi, SCi, 'L')
	def BondTree_PRO(self, BB, SC):
		''' Construct proline bond graph by adding sidechain to backbone '''
		BBb = self.AminoAcids[BB]['Bonds'].copy()
		SCb = self.AminoAcids[SC]['Bonds'].copy()
		for key in list(BBb.keys()): BBb[int(key)] = BBb.pop(key)
		for key in list(SCb.keys()): SCb[int(key)] = SCb.pop(key)
		length = len(SCb)
		BBb.pop(1)
		nBBb = {}
		for i, a in enumerate(BBb.items()):
			v = a[1]
			v = [x if x==0 else x-1 for x in v]
			nBBb[i] = v
		if BB == 'Backbone' or BB == 'Backbone start':
			n = 3
			nBBb[0][0] = length+1
			BBb = nBBb
		else:
			n = 1
			nBBb[0][0] = length-1
			BBb = nBBb
		for i in reversed(range(len(BBb))):
			if i > n+1:
				oldvals = BBb[i]
				newvals = [x if x<=n else x+length-1 for x in BBb[i]]
				oldk = i
				newk = i+length-1
				del BBb[i]
				BBb[newk] = newvals
		BBb[n].append(n+1+length)
		for i, (k, v) in enumerate(zip(SCb.keys(), SCb.values()), start=n+2):
			if k < 0: break
			k = i
			if BB == 'Backbone' or BB == 'Backbone start':
				v = [x+n+2 for x in v]
			else:
				v = [x+n+4 if x<0 else x+n+2 for x in v]
			if i == n+2: v.append(n)
			BBb[k] = v
			BBb[k] = sorted(BBb[k])
		return(BBb)
	def BondTree_AA(self, BB, SC):
		''' Construct amino acid bond graph by adding sidechain to backbone '''
		if SC == 'P':
			BBb = self.BondTree_PRO(BB, SC)
			return(BBb)
		BBb = self.AminoAcids[BB]['Bonds']
		SCb = self.AminoAcids[SC]['Bonds']
		for key in list(BBb.keys()): BBb[int(key)] = BBb.pop(key)
		for key in list(SCb.keys()): SCb[int(key)] = SCb.pop(key)
		length = len(SCb)
		if BB == 'Backbone' or BB == 'Backbone start':
			n = 4
		else:
			n = 2
		for i in reversed(range(len(BBb))):
			if i > n+1:
				oldvals = BBb[i]
				newvals = [x if x<=n else x+length for x in BBb[i]]
				oldk = i
				newk = i+length
				del BBb[i]
				BBb[newk] = newvals
		BBb[n].append(n+2+length)
		for i, (k, v) in enumerate(zip(SCb.keys(), SCb.values()), start=n+2):
			k = i
			if length != 1: v = [x+n+2 for x in v]
			if length == 1: v = [x+n+1 for x in v]
			if i == n+2 and length != 1: v.append(n)
			BBb[k] = v
			BBb[k] = sorted(BBb[k])
		return(BBb)
	def BondTree(self, BB, AA):
		''' Update the pose bond graph when adding a new amino acid '''
		BBb = self.BondTree_AA(BB, AA)
		BT = self.data['Bonds']
		length = len(BT)
		if length == 0:
			self.data['Bonds'] = BBb
			return
		i_max = max([k for k in BT.keys()])
		BT[i_max-1] += [i_max+1]
		for i in range(len(BBb)):
			K = i+length
			v = BBb[i]
			V = [x+length for x in v]
			if i == 0: V.append(i_max-1)
			BT[K] = V
		self.data['Bonds'] = BT
	def FASTA(self):
		''' Return FASTA sequence of peptide as a string '''
		AAs = self.data['Amino Acids']
		AAs = [x[0] for x in AAs.values()]
		FASTA = ''.join(AAs)
		return(FASTA)
	def SecondaryStructures(self):
		''' Return secondary strucutre of each amino acid of the peptide '''
		SS = [x[4] for x in self.data['Amino Acids'].values()]
		return(SS)
	def Distance(self, AA1, atom1, AA2, atom2):
		''' Measure distance between any two atoms '''
		A = self.GetAtom(AA1, atom1)
		B = self.GetAtom(AA2, atom2)
		mag = math.sqrt(np.sum((B-A)**2))
		mag = round(mag, 3)
		return(mag)
	def Size(self):
		''' Calculate length of peptide '''
		AAs = self.data['Amino Acids']
		AAs = [x[0] for x in AAs.values()]
		length = len(AAs)
		return(length)
	def AtomList(self, PDB=False):
		''' Return list of all the atoms '''
		As = self.data['Atoms']
		if PDB:
			As = [x[0] for x in As.values()]
		else:
			As = [x[1] for x in As.values()]
		return(As)
	def Identify(self, index, item, q=False):
		''' Identify an atom, atom charge, or amino acid given its index '''
		if item.upper() == 'ATOM':
			Atom = self.data['Atoms'][index]
			if q: return(Atom[-1])
			else: return(Atom[0])
		elif item.upper() == 'RESIDUE' or item.upper() == 'AMINO ACID':
			AminoAcid = self.data['Amino Acids'][index][0]
			return(AminoAcid)
		else:
			raise Exception('Incorrect item')
	def Mass(self):
		''' Calculate mass of peptide in Da'''
		atoms = self.AtomList()
		masses = [self.Masses[x] for x in atoms]
		mass = sum(masses)
		mass = round(mass, 3)
		return(mass)
	def Rg(self):
		''' Calculate the radius of gyration of a peptide '''
		coord = self.data['Coordinates'].tolist()
		atoms = self.AtomList()
		mass = [self.Masses[x] for x in atoms]
		xm = [(m*i, m*j, m*k) for (i, j, k), m in zip(coord, mass)]
		tmass = sum(mass)
		rr = sum(mi*i + mj*j + mk*k for (i,j,k), (mi,mj,mk) in zip(coord, xm))
		mm = sum((sum(i) / tmass)**2 for i in zip(*xm))
		rg = math.sqrt(rr / tmass-mm)
		return(round(rg, 3))
	def Atom3Angle(self, AA1, atom1, AA2, atom2, AA3, atom3):
		''' Measure the angle between three atoms '''
		atom1 = self.GetAtom(AA1, atom1)
		atom2 = self.GetAtom(AA2, atom2)
		atom3 = self.GetAtom(AA3, atom3)
		A = atom2 - atom1
		B = atom2 - atom3
		magA = math.sqrt(A[0]**2 + A[1]**2 + A[2]**2)
		magB = math.sqrt(B[0]**2 + B[1]**2 + B[2]**2)
		cos_theta = np.dot(A, B) / (magA * magB)
		theta = math.acos(cos_theta)
		theta = theta * 180 / math.pi
		return(theta)
	def Info(self):
		''' Print all basic info about a peptide '''
		print('Sequence:\t{}'.format(self.data['FASTA']))
		print('SS:\t\t{}'.format(''.join(self.SecondaryStructures())))
		print('Mass:\t\t{} Da'.format(self.data['Mass']))
		print('Size:\t\t{} residues'.format(self.data['Size']))
		print('Rg:\t\t{} Ã…'.format(self.data['Rg']))
		print('Energy:\t\t{}'.format(self.data['Energy']))
	def Build(self, sequence, chain='A'):
		''' Build a polypeptide primary structure from sequence '''
		sequence = sequence.upper()
		X, Y, Z = 0, 0, 0
		Ex_adjust, Ey_adjust, Ez_adjust = 0.400, 1.472, 0
		Ox_adjust, Oy_adjust, Oz_adjust = 0.812, 0.940, 0
		for i, aa in enumerate(list(sequence)):
			if len(sequence) == 1:
				I = len(self.data['Coordinates']) - 1
				self.Amino('Backbone', X, Y, Z, aa, [6])
				AAs = self.AminoAcids['Backbone']['Backbone Atoms']
				self.Atoms(aa, chain, AAs, 6, i, I)
				self.BondTree('Backbone', aa)
			elif i == 0:
				I = len(self.data['Coordinates']) - 1
				self.Amino('Backbone start', X, Y, Z, aa, [6])
				AAs = self.AminoAcids['Backbone start']['Backbone Atoms']
				self.Atoms(aa, chain, AAs, 6, i, I)
				self.BondTree('Backbone start', aa)
			elif i == len(sequence)-1:
				if (i % 2) != 0:
					X = self.data['Coordinates'][-2][0] + Ex_adjust
					Y = self.data['Coordinates'][-2][1] + Ey_adjust
					Z = self.data['Coordinates'][-2][2] + Ez_adjust
					I = len(self.data['Coordinates']) - 0
					self.Amino('Backbone end', X, Y, Z, aa, [4], flip=True)
					AAs = self.AminoAcids['Backbone end']['Backbone Atoms']
					self.Atoms(aa, chain, AAs, 4, i, I)
					self.BondTree('Backbone end', aa)
				elif (i % 2) == 0:
					X = self.data['Coordinates'][-2][0] + Ox_adjust
					Y = self.data['Coordinates'][-2][1] + Oy_adjust
					Z = self.data['Coordinates'][-2][2] + Oz_adjust
					I = len(self.data['Coordinates']) - 0
					self.Amino('Backbone end', X, Y, Z, aa, [4])
					AAs = self.AminoAcids['Backbone end']['Backbone Atoms']
					self.Atoms(aa, chain, AAs, 4, i, I)
					self.BondTree('Backbone end', aa)
			else:
				if (i % 2) != 0:
					X = self.data['Coordinates'][-2][0] + Ex_adjust
					Y = self.data['Coordinates'][-2][1] + Ey_adjust
					Z = self.data['Coordinates'][-2][2] + Ez_adjust
					I = len(self.data['Coordinates']) - 0
					self.Amino('Backbone middle', X, Y, Z, aa, [4], flip=True)
					AAs = self.AminoAcids['Backbone middle']['Backbone Atoms']
					self.Atoms(aa, chain, AAs, 4, i, I)
					self.BondTree('Backbone middle', aa)
				elif (i % 2) == 0:
					X = self.data['Coordinates'][-2][0] + Ox_adjust
					Y = self.data['Coordinates'][-2][1] + Oy_adjust
					Z = self.data['Coordinates'][-2][2] + Oz_adjust
					I = len(self.data['Coordinates']) - 0
					self.Amino('Backbone middle', X, Y, Z, aa, [4])
					AAs = self.AminoAcids['Backbone middle']['Backbone Atoms']
					self.Atoms(aa, chain, AAs, 4, i, I)
					self.BondTree('Backbone middle', aa)
		self.data['Mass'] = self.Mass()
		self.data['FASTA'] = self.FASTA()
		self.data['Size'] = self.Size()
		self.data['Rg'] = self.Rg()
	def Adjust(self, AA1, atom1, AA2, atom2, distance):
		''' Change the distance between any two atoms '''
		A = self.GetAtom(AA1, atom1)
		B = self.GetAtom(AA2, atom2)
		mag = math.sqrt(np.sum((B-A)**2))
		mut = distance/mag
		aa1 = self.data['Amino Acids'][AA1][0]
		aa1 = atom1 in [x[0] for x in self.AminoAcids[aa1]['Sidechain Atoms']]
		aa2 = self.data['Amino Acids'][AA2][0]
		aa2 = atom2 in [x[0] for x in self.AminoAcids[aa2]['Sidechain Atoms']]
		Aelements = (self.data['Coordinates'] == A)
		Awhole_row = Aelements.all(axis=1)
		Aindex = np.argwhere(Awhole_row)[0][0]
		Belements = (self.data['Coordinates'] == B)
		Bwhole_row = Belements.all(axis=1)
		Bindex = np.argwhere(Bwhole_row)[0][0]
		if aa2 or aa1:
			raise Exception('Distance adjustments allowed only for backbone')
		else:
			before = self.data['Coordinates'][:Bindex]
			after = self.data['Coordinates'][Bindex:]
			nB = B * mut
			after = after - B + nB
			new = np.concatenate((before, after))
			self.data['Coordinates'] = new
	def Angle(self, AA, angle_type, chi_type=None):
		''' Measure angle at bond '''
		AminoAcid = self.data['Amino Acids'][AA][0]
		if angle_type.upper() == 'PHI':
			if AA == 0: r1 = self.GetAtom(AA, 'N') - self.GetAtom(AA, 'CA')
			else: r1 = self.GetAtom(AA-1, 'C')
			r2 = self.GetAtom(AA, 'N')
			r3 = self.GetAtom(AA, 'CA')
			r4 = self.GetAtom(AA, 'C')
		if angle_type.upper() == 'PSI':
			r1 = self.GetAtom(AA, 'N')
			r2 = self.GetAtom(AA, 'CA')
			r3 = self.GetAtom(AA, 'C')
			try:
				r4 = self.GetAtom(AA+1, 'N')
			except:
				r4 = self.GetAtom(AA,'C')+self.GetAtom(AA,'CA')+[0.091,0.025,0]
		if angle_type.upper() == 'OMEGA':
			r1 = self.GetAtom(AA, 'CA')
			r2 = self.GetAtom(AA, 'C')
			try:
				r3 = self.GetAtom(AA+1, 'N')
				r4 = self.GetAtom(AA+1, 'CA')
			except: return(180.0)
		if angle_type.upper() == 'CHI':
			assert type(chi_type) is int, 'Incorrect Chi angle type'
			number_of_chis = len(self.AminoAcids[AminoAcid]['Chi Angle Atoms'])
			if not (number_of_chis >= chi_type):
				error = '{} amino acid at position {} has no Chi {} angle' \
				.format(AminoAcid, AA, chi_type)
				raise Exception(error)
			atoms = self.AminoAcids[AminoAcid]['Chi Angle Atoms'][chi_type - 1]
			r1 = self.GetAtom(AA, atoms[0])
			r2 = self.GetAtom(AA, atoms[1])
			r3 = self.GetAtom(AA, atoms[2])
			r4 = self.GetAtom(AA, atoms[3])
		u1 = r2 - r1
		u2 = r3 - r2
		u3 = r4 - r3
		mag_u2 = np.linalg.norm(u2)
		u1u2 = np.cross(u1, u2)
		u2u3 = np.cross(u2, u3)
		u1u2Cu2u3 = np.cross(u1u2, u2u3)
		u1u2Du2u3 = np.dot(u1u2, u2u3)
		a = np.dot(u2, u1u2Cu2u3)
		b = mag_u2 * u1u2Du2u3
		theta = math.atan2(a, b) * 180 / math.pi
		theta = round(theta, 2)
		return(theta)
	def Rotation_Matrix(self, theta, u):
		''' Rotate a matrix around axis u by theta angle '''
		ux, uy, uz = u[0], u[1], u[2]
		S = math.sin(math.radians(theta))
		C = math.cos(math.radians(theta))
		R = np.array([
		[C+ux**2*(1-C)   , ux*uy*(1-C)-uz*S, ux*uz*(1-C)+uy*S],
		[uy*ux*(1-C)+uz*S, C+uy**2*(1-C)   , uy*uz*(1-C)-ux*S],
		[uz*ux*(1-C)-uy*S, uz*uy*(1-C)+ux*S, C+uz**2*(1-C)   ]])
		return(R)
	def Rotate(self, AA, theta, angle_type, chi_type=None):
		''' Rotate around a bond '''
		AminoAcid = self.data['Amino Acids'][AA][0]
		if angle_type.upper() == 'PHI':
			ori = self.GetAtom(AA, 'CA')
			n = 1
			if AA == 0: n = 3
			index = self.data['Amino Acids'][AA][2][2]
			before = self.data['Coordinates'][:index + n]
			after = self.data['Coordinates'][index + n:]
			after = after - ori
			A = self.GetAtom(AA, 'CA')
			B = self.GetAtom(AA, 'N')
			u = B - A
			lu = np.linalg.norm(u)
			u = u / lu
			current = self.Angle(AA, 'phi')
			zeroing = 0 - current
			RM = self.Rotation_Matrix(zeroing, u)
			after = np.matmul(after, RM)
			RM = self.Rotation_Matrix(theta, u)
			after = np.matmul(after, RM)
			after = after + ori
			combine = np.append(before, after, axis=0)
			self.data['Coordinates'] = combine
		if angle_type.upper() == 'PSI':
			ori = self.GetAtom(AA, 'C')
			n = 0
			index = self.data['Amino Acids'][AA][2][4]
			before = self.data['Coordinates'][:index + n]
			after = self.data['Coordinates'][index + n:]
			after = after - ori
			A = self.GetAtom(AA, 'C')
			B = self.GetAtom(AA, 'CA')
			u = B - A
			lu = np.linalg.norm(u)
			u = u / lu
			current = self.Angle(AA, 'psi')
			zeroing = 0 - current
			RM = self.Rotation_Matrix(zeroing, u)
			after = np.matmul(after, RM)
			RM = self.Rotation_Matrix(theta, u)
			after = np.matmul(after, RM)
			after = after + ori
			combine = np.append(before, after, axis=0)
			self.data['Coordinates'] = combine
		if angle_type.upper() == 'OMEGA':
			ori = self.GetAtom(AA + 1, 'N')
			n = 0
			index = self.data['Amino Acids'][AA + 1][2][0]
			before = self.data['Coordinates'][:index + n]
			after = self.data['Coordinates'][index + n:]
			after = after - ori
			A = self.GetAtom(AA + 1, 'N')
			B = self.GetAtom(AA, 'C')
			u = B - A
			lu = np.linalg.norm(u)
			u = u / lu
			current = self.Angle(AA, 'omega')
			zeroing = 0 - current
			RM = self.Rotation_Matrix(zeroing, u)
			after = np.matmul(after, RM)
			RM = self.Rotation_Matrix(theta, u)
			after = np.matmul(after, RM)
			after = after + ori
			combine = np.append(before, after, axis=0)
			self.data['Coordinates'] = combine
		if angle_type.upper() == 'CHI':
			assert type(chi_type) is int, 'Incorrect Chi angle type'
			number_of_chis = len(self.AminoAcids[AminoAcid]['Chi Angle Atoms'])
			if not (number_of_chis >= chi_type):
				error = '{} amino acid at position {} has no Chi {} angle'\
				.format(AminoAcid, AA, chi_type)
				raise Exception(error)
			atoms = self.AminoAcids[AminoAcid]['Chi Angle Atoms'][chi_type-1]
			A = self.GetAtom(AA, atoms[1])
			B = self.GetAtom(AA, atoms[2])
			ori = B
			start = self.AminoAcids[AminoAcid]['Chi Angle Atoms'][chi_type-1][2]
			L = self.AminoAcids[AminoAcid]['Sidechain Atoms']
			i = [x[0] for x in L].index(start)
			Sindex = self.data['Amino Acids'][AA][3][i]
			Eindex = self.data['Amino Acids'][AA][3][-1]
			before = self.data['Coordinates'][:Sindex]
			side   = self.data['Coordinates'][Sindex:Eindex + 1]
			after  = self.data['Coordinates'][Eindex + 1 :]
			side = side - ori
			u = A - B
			lu = np.linalg.norm(u)
			u = u / lu
			current = self.Angle(AA, 'chi', chi_type)
			zeroing = 0 - current
			RM = self.Rotation_Matrix(zeroing, u)
			side = np.matmul(side, RM)
			RM = self.Rotation_Matrix(theta, u)
			side = np.matmul(side, RM)
			side = side + ori
			combine = np.append(before, side, axis=0)
			combine = np.append(combine, after, axis=0)
			self.data['Coordinates'] = combine
	def Mutate(self, index, new_AA):
		''' Mutate an amino acid into a different amino acid '''
		old_AA = self.data['Amino Acids'][index][0]
		list_SC = self.data['Amino Acids'][index][3]
		before = self.data['Coordinates'][:list_SC[0]]
		old_side = self.data['Coordinates'][list_SC[0]:list_SC[-1] + 1]
		after = self.data['Coordinates'][list_SC[-1] + 1:]
		local_N = self.GetAtom(index, 'N')
		X, Y, Z =  local_N[0], local_N[1], local_N[2]
		new_SC = self.Insert(new_AA, X, Y, Z)
		difference = len(new_SC) - len(old_side)
		side = new_SC
		CAi = self.GetAtom(index, 'CA')
		oldSC = old_side - CAi
		CAl = pose.GetAtom(index, 'N') + np.array([1.458, 0, 0])
		newSC = side - CAl
		i = oldSC[0]
		ui = i / np.linalg.norm(i)
		l = newSC[0]
		ul = l / np.linalg.norm(l)
		v = np.cross(ui, ul)
		sint = np.linalg.norm(v)
		cost = np.dot(ui, ul)
		skew = np.array(
			[[  0, -v[2], v[1]],
			[ v[2],   0, -v[0]],
			[-v[1], v[0],   0]])
		R = np.identity(3) + skew + (np.dot(skew, skew) *((1-cost)/sint**2))
		side = np.matmul(newSC, R)
		side = side + CAi
		chain = self.data['Amino Acids'][index][1]
		n = 4
		if index == 0: n = 6
		BBi_before = self.data['Amino Acids'][index][2][:n]
		BBi_after = self.data['Amino Acids'][index][2][n:]
		BBi_after = [x + difference for x in BBi_after]
		BBi = BBi_before + BBi_after
		len_SCi = len(self.AminoAcids[new_AA]['Sidechain Atoms'])
		SCi = [x + 1 + BBi_before[-1] for x in range(len_SCi)]
		self.data['Amino Acids'][index] = (new_AA, chain, BBi, SCi, 'L')
		AA_dict = self.data['Amino Acids']
		for k, v in zip(AA_dict.keys(), AA_dict.values()):
			if k > index:
				aa = v[0]
				ch = v[1]
				bb = [x + difference for x in v[2]]
				sc = [x + difference for x in v[3]]
				ss = v[4]
				self.data['Amino Acids'][k] = (aa, ch, bb, sc, ss)
		atoms = self.data['Atoms']
		ori_len = len(self.data['Atoms'])
		before_indices = [x for x in range(BBi_before[-1] + 1)]
		before_values = []
		for k, v in zip(atoms.keys(), atoms.values()):
			if k <= BBi_before[-1]:
				before_values.append(v)
		side_values = [x for x in self.AminoAcids[new_AA]['Sidechain Atoms']]
		R = range(BBi_before[-1] + 1, BBi_before[-1] + len(side_values) + 1)
		side_indices = [x for x in R]
		after_indices = [x + difference for x in range(list_SC[-1]+1, ori_len)]
		after_values = []
		for k, v in zip(atoms.keys(), atoms.values()):
			if k >= list_SC[-1] + 1:
				after_values.append(v)
		new_Atoms = {}
		for k, v in zip(before_indices, before_values):
			new_Atoms[k] = v
		for k, v in zip(side_indices, side_values):
			new_Atoms[k] = v
		for k, v in zip(after_indices, after_values):
			new_Atoms[k] = v
		self.data['Atoms'] = new_Atoms
		new = np.concatenate((before, side, after))
		self.data['Coordinates'] = new
		self.data['Mass'] = self.Mass()
		self.data['FASTA'] = self.FASTA()
		self.data['Length'] = self.Size()
		self.data['Rg'] = self.Rg()
